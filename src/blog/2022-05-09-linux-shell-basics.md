---
title: ისწავლეთ Linux & Bash
date: 2022-05-09
image: https://img.youtube.com/vi/Ca6DID6liyo/maxresdefault.jpg
imageAlt: Image of Linux BASH logo and title
language: geo
description: შელის საშუალებით გვაქვს ულევი პოტენციალი, რომლითაც კომპიუტერს შეგვიძლია გავაკეთებინოთ ზუსტად ის, რაც ჩვენ გვინდა და არ დავჯერდეთ იმ შეზღუდული ფუნქციების რეპერტუარს, რომელსაც რომელიმე გრაფიკული აპლიკაცია გვთავაზობს. მთავარი შეზღუდვა მხოლოდ ადამიანის ცოდნა და წარმოსახვაა.
---

# Shell (გარსი)

რა არის შელი? მარტივად რომ ვთქვათ, შელი არის პროგრამა, რომელიც კლავიატურიდან იღებს
ბრძანებებს და მას ოპერატიულ სისტემას გადასცემს შესასრულებლად. ალბათ კომპიუტერში
გინახავთ პროგრამები, სახელად "Terminal", "Console", "CMD", "PowerShell". ესენი პროგრამებია,
რომლებიც შენთვის შელს ხსნიან.

რაში გვჭირდება შელი? ამის სადემონსტრაციოდ მარტივ მაგალითს მოგიყვანთ ჩემი გამოცდილებიდან.
ახალი ტექნოლოგიის ვიდეო გაკვეთილები გადმოვწერე. ვიდეოები თემის მიხედვით
დაყოფილი იყო ფაილებად. თითო ფაილში იქნებოდა 20-მდე ვიდეო mp4 ფორმატით, რომელსაც
ასევე ახლდა .srt ფორმატის ფაილები სუბტიტრებისთვის. საქმე ისაა, რომ მე სუბტიტრები საერთოდ
არ მჭირდებოდა - ის ტყუილად იკავებდა ფოლდერში სივრცეს და სასწავლი მასალაც თითქოს ორჯერ
დიდი ჩანდა, ვიდრე ეს სინამდვილეში იყო. ამ სუბტიტრების ფაილების წასაშლელად ერთი მარტივი გზა
ვიცი, თუმცა ბევრი თქვენგანი ალბათ შემდეგნაირად მოიქცეოდა: გახსნიდით იმ ფოლდერს (გრაფიკული
აპლიკაციით) სადაც ვიდეოებია მოთავსებული, ctrl ღილაკითა და მაუსზე დაკლიკებით სათითაოდ აარჩევდით
სუბტიტრების ფაილებს, შემდეგ მარჯვენა კლიკით გახსნიდით მენიუს და იქედან დააჭერდით წაშლის ღილაკს.
ზოგს შეიძლება ჯერ ფოლდერი ფაილების ტიპის მიხედვით დაესორტირებინა და ასე უფრო მალე მოენიშნა
სუბტიტრების ფაილები, მაგრამ წარმოიდგინეთ და ამის ათასჯერ უფრო მარტივად გაკეთება შეიძლება.
ტერმინალში გავხსნით ვიდეოების ფოლდერს და დავწერთ:

```bash
rm *.srt
```

ეს ბრძანება მიმდინარე ფოლდერში წაშლის ყველა ფაილს, რომელიც .srt-ით ბოლოვდება.

ეს არის შელის და ზოგადად კომპიუტერის ნამდვილი ხიბლი: ის რუტინულ და მოსაწყენ სამუშაოს ჩვენ
მაგივრად აკეთებს. ბევრი თანამედროვე პროგრამა, რომელიც ფართო აუდიტორიაზეა გათვლილი არათუ
საშუალებას არ გვაძლევს, რომ საქმე გავიმარტივოთ, არამედ, ხშირ შემთხვევაში, საქმეს გვირთულებს კიდევაც.

შელის საშუალებით გვაქვს ულევი პოტენციალი, რომლითაც კომპიუტერს შეგვიძლია გავაკეთებინოთ
_ზუსტად_ ის, რაც ჩვენ გვინდა და არ დავჯერდეთ იმ შეზღუდული ფუნქციების რეპერტუარს, რომელსაც
რომელიმე გრაფიკული აპლიკაცია გვთავაზობს. მთავარი შეზღუდვა მხოლოდ ადამიანის ცოდნა და
წარმოსახვაა. მოდით, სწორედ ცოდნის ასპექტს მივხედოთ და დარწმუნებული, ვარ წარმოსახვასაც
გავამდიდრებთ, როცა ნახავთ როგორი ძლევამოსილები გახდებით ამ ცოდნით.

გაითვალისწინეთ, რომ შელი ნებისმიერი ადამიანისთვის სასარგებლოა, იქნება ეს მორიგი ადამიანი,
რომელსაც კომპიუტერზე ოპერაციების სწრაფად და ეფექტურად შესრულება უნდა თუ პროგრამისტი.
პროგრამისტებისთვის შელი, რა თქმა უნდა, განსაკუთრებით მარგებელია, რადგან მისი გამოყენების
სწავლა, ერთი მხრივ, უფრო მარტივია, ხოლო მეორე მხრივ, რადგან ისინი მნიშვნელოვან დროს უთმობენ
კომპიუტერზე მუშაობას, შეძლებენ უფრო სიღრმისეულად შეისწავლონ თავიანთი ოპერატიული სისტემა
და მოიაწყონ ის ზუსტად ისე, როგორც მათ მოესურვებათ.

ამ (და სავარაუდოდ მომავალ) გაკვეთილში ვისწავლით bash-ის (Bourne Again Shell) გამოყენებას,
რომელიც მრავალთაგან ერთ-ერთი შელია. იგი ინტეგრირებულია თითქმის ყველა ლინუქსის დისტრიბუციაში.

**შენიშვნა:** ამ გაკვეთილს თავისუფლად შეგიძლიათ მიყვეთ MacOS-ის მომხმარებლებიც, სადაც შელი არის
zsh (ან ძველ მოდელებში bash). ძირითადად, ბევრი რამ, რასაც bash-ზე განვიხილავთ, გავრცელდება
zsh-ზეც.

ეს გაკვეთილი ეფუძნება [linuxjourney.com](https://linuxjourney.com/)-ზე არსებულ მასალას.

დავიწყოთ შელის განხილვა. გახსენით თქვენთვის ხელმისაწვდომი ტერმინალი. პირველი, რასაც
დაინახავთ, არის პრომპტი, რომელიც კონკრეტული შელისა და ოპერატიული სისტემისთვის
განსხვავებულია, თუმცა ის ერთ ფორმატს მიყვება:

```
მომხმარებელი@მოწყობილობა:მიმდინარე_დირექტორია
```

მაგალითად:

```bash
[pridon@laptop:~/Documents]$

```

პრომპტის ბოლოს `$` დამახასიათებელია bash-ისთვის. ის პრომპტის ნაწილია და მას ჩვენ ბრძანებაში
**არ** ვწერთ. ის დოკუმენტაციებში იმის მისანიშნებლად წერია ხოლმე, რომ მოცემული ბრძანება შელში ხორციელდება.

გავცეთ მარტივი ბრძანება `echo`. იგი ეკრანზე ამობეჭდავს იმ ტექსტს, რომელსაც ჩვენ არგუმენტად მივაწოდებთ.

```bash
$ echo Hello World!
```

# pwd (მუშა დირექტორიის ამობეჭდვა)

ლინუქსში ყველაფერი ფაილია. ის ბრძანებაც კი, რომელსაც ჩვენ შელს ვაძლევთ, გადაეცემა კონკრეტულ
ფაილს, სადაც ის ინერპრეტირდება: `/usr/bin/bash`. ამას უკეთ გავიაზრებთ მოგვიანებით, როცა ლინუქსს
სიღრმისეულად განვიხილავთ. ყველა ფაილი ორგანიზებულია იერარქიულად, როგორც ხე. უპირველეს
დირექტორიას ეწოდება root, იგივე ფესვი ან ფუძე. ამ დირექტორიას შიგნით აქვს მრავალი ფოლდერი და ფაილები.
მაგალითისთვის, დირექტორიის ხე ასე გამოიყურება:

```txt
/
|-- bin
|   |-- file1
|   |-- file2
|-- etc
|   |-- file3
|   `-- directory1
|       |-- file4
|       `-- file5
|-- home
|-- var
```

ამ ფაილების ადგილმდებარეობას უწოდებენ path-ს, ბილიკს ან გზას. თუ გვაქვს ფაილი სახელად file, რომელიც მოთავსებულია
home ფოლდერში, მისი path იქნება: `/home/file`. აქედან გამომდინარე, რომ ავაგოთ სქემიდან file5-ის ბილიკი, გამოგვივა: `/etc/directory1/file5`.

ფაილთა სისტემაში ნავიგაცია, ისევე როგორც ცხოვრებაში, მარტივია როცა იცი სად ხარ და საით მიდიხარ.
იმის გასარკვევად, თუ სად ხარ, შეგიძლია გამოიყენო `pwd` ბრძანება, რომელიც ნიშნავს შემდეგს: "Print working directory" (ამობეჭდე მუშა დირექტორია\/ფოლდერი). ის გიჩვენებს იმ დირექტორიას, სადაც ამჟამად იმყოფები. გაითვალისწინე, რომ გზა (path) იწყება ფესვიდან.

```bash
$ pwd
```

აქვე აღვნიშნავ, რომ `~`, რომელიც ჩვენს პრომპტში შეიძლება ჩანდეს, მიუთითებს `/home/username` დირექტორიაზე,
შემოკლებული ფორმით. მაშასადამე, თუ ჩემი მომხმარებლის სახელია pridon, `~/Documents` სინამდვილეში არის `/home/pridon/Documents` (იხილეთ [cd-ს თავი](#cd-დირექტორიაში-გადანაცვლება) მეტი ინფორმაციისთვის).

# cd (დირექტორიაში გადანაცვლება)

რადგან უკვე ვიცით, სად ვიმყოფებით, ვნახოთ როგორ შეგვიძლია ფაილთა სისტემაში გადაადგილება.
ჩვენ გადაადგილებისთვის გზის (path) გამოყენება გვჭირდება. არსებობს ორი განსხვავებული მეთოდი, რომლითაც შეგვიძლია გზის მითითება:

- აბსოლუტური გზა: აბსოლუტური გზით, მისამართი იწყება ფესვიდან (root). იგი ჩვეულებრივ აღინიჭნება დახრილი ხაზით. ყოველთვის, როცა path იწყება `/`-ით, ეს იმას ნიშნავს, რომ ვიწყებთ root დირექტორიიდან. მაგალითად `/home/pridon/Pictures/cats`
- ფარდობითი გზა: ეს არის გზა, რომელიც იმ დირექტორიიდან იწყება, რომელშიც ჩვენ ამჟამად ვიმყოფებით. მაგალითად, თუ მე ვიმყოფები `/home/pridon/Pictures`-ში, და მინდა გადავინაცვლო ფოლდერში, სახელად cats, რომელიც Pictures ფოლდერში იმყოფება, მაშინ მე არ მჭირდება ასე მთელი მისამართის დაკონკრეტება `/home/pridon/Pictures/cats` მე უბრალოდ შემიძლია გადავინაცვლო ამ გზის გამოყენებით `cats/`.

ახლა, რადგან უკვე ვიცით როგორ მუშაობს path, უბრალოდ გვჭირდება იმ ბრძანების გამოყენება, რომელიც კონკრეტულ დირექტორიაში გადაგვიყვანს. ეს ბრძანებაა `cd`, იგივე "change directory" (ფოლდერის\/დირექტორიის შეცვლა).

```bash
$ cd /home/pridon/Pictures
```

ასე, ჩვენ გადავინაცვლეთ სხვა დირექტორიაში.

თუ, მაგალითად, მე ზემოთ ნaჩვენებ დირექტორიაში მაქვს ფოლდერი სახელად cats, ფარდობითი გზის მითითებით, შემიძლია იქ გადავინაცვლო შემდეგნაირად:

```bash
$ cd cats
```

აქ მე უბრალოდ ფოლდერის სახელი გამოვიყენე, და არ დავწერე აბსოლუტური გზა, რადგანაც უკვე ვიმყოფებოდი `/home/pridon/Pictures`-ში.

აბსოლუტური და ფარდობითი გზების წერა დამღლელი იქნებოდა, მაგრამ საბედნიეროდ არსებობს ხერხები გზის შესამოკლებლად:

- `.` (ამჟამინდელი დირექტორია). ეს ის დირექტორიაა, რომელშიც ამჟამად ვიმყოფებით.
- `..` (მშობელი დირექტორია). ეს გადაგვიყვანს ერთი დირექტორიით ზემოთ.
- `~` (home დირექტორია). ეს არის დირექტორია, რომელიც ინტერპრეტირდება როგორც "home directory", მაგალითად `/home/pridon`.
- `-` (წინა დირექტორია). ეს გადაგვიყვანს წინა დირექტორიაში, რომელშიც ვიმყოფებოდით.

```bash
$ cd .

$ cd ..

$ cd ~

$ cd -
```

**რჩევა:** ყველაზე სწრაფად home-ზე გადასასვლელად შეგვიძლია უბრალოდ დავწეროთ `cd` ყოველგვარი არგუმენტის გარეშე.

# ls (დირექტორიათა სია)

სისტემაში გადაადგილება ვიცით. ახლა როგორ გავიგოთ რა ფაილები და ფოლდერებია ჩვენთვის ხელმისაწვდომი? ამ ეტაპზე ჩვენ სიბნელეში დავდივართ, მაგრამ შეგვიძლია დირექტორიას ნათელი მოვფინოთ `ls` ბრძანებით, რომელიც ჩამოგვიწერს ფოლდერში არსებული ფოლდერებისა და ფაილებს.
ჩვეულებრივ, ეს ბრძანება ჩამოგვიწერს ფაილთა სიას იმ დირექტორიაში, რომელშიც ვიმყოფებით, მაგრამ შეგვიძლია დავაზუსტოთ, კონკრეტულად რა path-ის ფოლდერები და ფაილები გვინდა რომ ვნახოთ.

```bash
$ ls

$ ls /home/pridon
```

ეს ბრძანება დეტალურ ინფორმაციას გვაწვდის იმ ფაილებსა და ფოლდერების შესახებ, რომლებსაც ვუყურებთ.

გასათვალისწინებელია, რომ ბრძანება დირექტორიაში ყველა ფაილს ავტომატურად არ გამოაჩენს. ის ფაილები, რომლებიც იყება `.`-ით, დამალულებია, მაგრამ მათი გამოჩენა შეგვიძლია `ls` ბრძანებით, `-a` ფლაგის გატარებით (a ნიშნავს all-ს, ანუ "ყველას").

```bash
$ ls -a
```

კიდევ ერთი გამოსადეგი ფლაგი გვაქვს `ls`-ისთვის: `-l` რომელიც ნიშნავს გრძელს ან ვრცელს (long). ეს გვიჩვენებს ფაილის დეტალურ სიას, ვრცელი ფორმით. ეს ინფორმაცია, მარცხნიდან მარჯვნივ, არის ფაილის უფლებები, კავშირების ოდენობა, მფლობელის სახელი, მფლობელის ჯგუფი, ფაილის ზომა, შექმნის ან ბოლო მოდიფიკაციის დრო და ფაილის/ფოლდერის სახელი.

```bash
$ ls -l
```

<br>

```bash
[pridon@laptop:~]$ ls -l

total 80

drwxr-x--- 7 pridon devgroup   4096 Nov 20 16:37 Desktop

drwxr-x--- 2 pridon devgroup   4096 Oct 19 10:46 Documents

drwxr-x--- 4 pridon devgroup   4096 Nov 20 09:30 Downloads

drwxr-x--- 2 pridon devgroup   4096 Oct  7 13:13 Music

drwxr-x--- 2 pridon devgroup   4096 Sep 21 14:02 Pictures

drwxr-x--- 2 pridon devgroup   4096 Jul 27 12:41 Public

drwxr-x--- 2 pridon devgroup   4096 Jul 27 12:41 Templates

drwxr-x--- 2 pridon devgroup   4096 Jul 27 12:41 Videos

```

ბრძანებებს გააჩნიათ ე.წ ფლაგები (flags) (ან არგუმენტები, პარამეტრები), რომლებიც დამატებით ფუნქციებს წარმოადგენენ. ჩვენ ცალცალკე განვიხილეთ `-a` და `-l` ფლაგები, მაგრამ მათი გაერთიანებაც შეგვიძლია, როგორც `-la`. ფლაგების თანმიმდევრობა განსაზღვრავს, ფუნქციების განხორციელების თანმიმდევრობას, მაგრამ ხშირ შემთხვევაში ამას დიდი მნიშვნელობა არ აქვს. `ls -al` იგივენაირად იმუშავებს.

```bash
$ ls -la
```

# touch

ვისწავლოთ ფაილების შექმნა. `touch` ბრძანება საშუალებას გვაძლევს შევქმნათ ცარიელი ფაილი.

```bash
$ touch myfile
```

ამ ბრძანებით შეიქმნება ფაილი სახელად myfile (გამოიყენეთ `ls` ამის შესამოწმებლად).
ეს ბრძანება ასევე გამოიყენება არსებული ფაილების მოდიფიკაციის დროის შესაცვლელადაც.
სცადეთ - შეხედეთ ფაილებს `ls -l`-ით, რომელიმე აირჩიეთ, დაიმახსოვრეთ მისი დრო და მასზე გამოიყენეთ `touch`.

კიდევ ბევრი გზა არსებობს ფაილების შესაქმნელად, რომლებიც მოიცავენ გადამისამართებასა და ტექსტის ედიტორებს, მაგრამ ტექსტის მანიპულაცია ცალკე დიდი თემაა, რომელზეც მოგვიანებით გესაუბრებით.

# file

წინა ნაწილში ჩვენ ვისწავლეთ `touch`. ცოტა ხნით ამ საკითხს დავუბრუნდეთ. შეამჩნიეთ, რომ ფაილის სახელი არ ექვემდებარებოდა დასახელების სტანდარტს, რომელიც შესაძლოა სხვა ოპერატიულ სისტემებზე, მაგალითად ვინდოუსზე გენახათ? ჩვეულებრივ, მოლოდინი გვაქვს, რომ ბანანი.jpg იქნება JPEG ტიპის სურათის ფაილი.

ლინუქსში ფაილების სახელები არ არის აუცილებელი ფაილის შიგთავსის განსაზღვრისთვის. შენ შეგიძლია შექმნა ფაილი სახელად სასაცილო.gif, რომელიც სინამდვილეში არ არის GIF.

იმის გასარკვევად, თუ რანაირი ფაილია რაიმე ფაილი, ჩვენ შეგვიძლია გამოვიყენოთ `file` ბრძანება.
ის ფაილის შიგთავსს აღგვიწერს.

```bash
$ file something.jpg
```

# cat

ვისწავლოთ ფაილების წაკითხვა. ამ შემთხვევაში გვაქვს ერთი მარტივი ბრძანება `cat`, რომელიც სიტყვა concatenate-ის (შეერთება) შემოკლებული ფორმაა. მას არამხოლოდ ფაილის შიგათავსის გადმოცემა შეუძლია, არამედ სხვადასხვა ფაილების კომბინაცია და მათი შიგთავსის ერთიანად გადმოცემა.

```bash
$ cat dogfile birdfile
```

ეს ბრძანება იდეალური არაა დიდი ზომის ფაილების დასათვალიერებლად, იგი განკუთვნილია პატარა ფაილების წასაკითხად. ბევრი სხვა ხელსაწყო არსებობს დიდი ტექსტური ფაილების სანახავად, მათ შორისაა `less`.

# less

თუ დიდი ფაილების წაკითხვა გვაქვს განზრახული, `less` ბრძანება გამოგვადგება. მისი საშუალებით ტექსტი წარმოდგენილი იქნება გვერდებად, რაც საშუალებას გვაძლევს ტექსტში გადავადგილდეთ ერთი გვერდიდან მეორეზე.

სცადეთ ფაილის შიგთავსის გახსნა ამ ბრძანებით. `less`-ში გადაადგილება შესაძლებელია კლავიატურით.

```bash
$ less /home/pridon/Documents/large_text
```

გამოიყენეთ შემდეგი ღილაკები სანავიგაციოდ:

- q - გამოიყენება `less`-დან გამოსასვლელად და შელში დასაბრუნებლად.
- Page up, Page down - ზემოთ და ქვემოთ გადასასვლელად. ასევე გამოიყენება კლავიატურის ისრები.
- g - გადაგვიყვანს ფაილის დასაწყისში
- G - გადაგვიყვანს ფაილის ბოლოში
- /search - გამოიყენება კონკრეტული ტექსტის მოსაძებნად ფაილში. საძიებო სიტყვებს წინ უნდა დავურთოთ `/`.
- h - ხსნის დახმარების სექციას, რათა `less`-ში ვნახოთ, როგორ გამოვიყენოთ პროგრამა.

# history

ჩვენს შელში არის შენახული იმ ბრძანებათა ისტორია, რომელიც ჩვენ აქამდე გამოგვიყენებია.
ჩვენ შეგვიძლია შევხედოთ ამ ბრძანებებს. ეს ძალიან მოხერხებული ხელსაწყოა როცა იმ ბრძანების მოძებნა და ხელახლა გაშვება გვინდა, რომელიც აქამდე გამოგვიყენებია, მისი ხელახლა დაწერის გარეშე.

```bash
$ history
```

ეს ბრძანება გვაჩვენებს აქამდე გამოყენებული ბრძანებების სიას.

თუ გვინდა იმავე ბრძანების გაშვება, რაც ბოლოს განვახორციელეთ, შეგვიძლია უბრალოდ დავაჭიროთ ზედა ისარს კლავიატურაზე. ეს ბრძანების ჩასაწერ ველში ხელახლა განათავსებს უწინ გაშვებულ ბრძანებას.

თუ გვინდა ბოლო ბრძანების გამეორება, ასევე შეგვიძლია გამოვიყენოთ `!!`. თუ, ვთქვათ შელში გავეცით ბრძანება `cat file1`, შეგვიძლია პირდაპირ დავწოთ `!!` და იგივე ბრძანება გავიმეოროთ.

კიდევ ერთი ილეთი, რაც ისტორიას ეხება, არის ღილაკების კომბინაცია ctrl-R, ესაა შებრუნებული ძებნის ბრძანება. თუ ამ ღილაკებს დავაჭერთ და ჩავწერთ სასურველი ბრძანების ნაწილს, პროგრამა ამოგვიყრის მსგავს ბრძანებებს, რომლებიც აქამდე გამოგვიყენებია. ამ ბრძანებებს შორის ნავიგაცია იმავე ღილაკით შეგვიძლია. როცა ჩვენთვის სასურველ ბრძანებას მივაგნებთ, მის გასაშვებად ვაჭერთ enter-ს.

ამ ეტაპზე ჩვენი ტერმინალი ალბათ გადავსებულია. ჩვენ მისი გაწმენდა შეგვიძლია ბრძანებით:

```bash
$ clear
```

ან უფრო მარტივად, ღილაკების კომბინაციით: ctrl-L.

კიდევ ერთი ძალიან მნიშვნელოვანი საკითხი არის ავტო-შევსება. თუკი ჩვენ ბრძანების ნაწილის დაწერას დავიწყებთ და დავაჭერთ tab ღილაკს, შელი ამვომატურად შეგვივსებს ველს იმის მიხედვით, თუ რას მიაგნებს ის იმ დირექტორიაში, რომელშიც შენ ასრულებ ბრძანებას, ან არსებულ ბრძანებათა სიაში.
მაგალითად, თუკი ჩვენ გვაქვს აპლიკაცია firefox, ტერმინალში შეგვიძლია ჩავწეროთ `fire` და დავაჭიროთ tab-ს.

ფაილის მოძებნისას აუცილებელია, რომ ის ნაწილობრივი ტექსტი რაც გვიწერია ბრძანებაში, არ ემთხვეოდეს ერთზე მეტი ფაილების საწყისს სახელს. ამ შემთხვევაში შელი ამოგვიგდებს ყველა იმ ფაილსა თუ ფოლდერს, რომლის სახელიც ჩვენს ფრაგმენტებს ემთხვევა და რომლიდანაც ჩვენ უნდა ამოვარჩიოთ ერთ-ერთი.

სანიმუშოდ სცადეთ დაწეროთ `ls /home/` და დააჭიროთ tabs-ს რამდენიმეჯერ.

# cp (კოპირება)

მოდით ფაილის კოპირება ვცადოთ. ბრძანება ჰგავს კოპი-ფეისთის ფუნქციას სხვა ოპერატიულ სისტემებში, მაგრამ შელი ამ საქმის შესრულების უფრო მარტივ გზას გვთავაზობს.

```bash
$ cp mycoolfile /home/pridon/Documents/cooldocs
```

ამ ბრძანებით ჩვენ ავიღეთ mycoolfile და ის გადავაკოპირეთ `/home/pridon/Documents/cooldocs` ფოლდერში.

ჩვენ შეგვიძლია რამდენიმე ფაილისა და დირექტორიის ერთდროულად კოპირება, ამასთანავე, wildcard-ების გამოყენებაც. wildcard არის სიმბოლო, მნიშვნელობა, რომელიც ჩვენთვის უცნობია, მაგრამ შეიძლება არსებობდეს. wildcard-ის სიმბოლო შეგვიძლია გამოვიყენოთ იმ ფაილების მოსანიშნად, რომლებსაც საზიარო პატერნი ან რაიმე სხვა თვისება აქვთ. wildcard შეგვიძლია ნებისმიერ ბრძანებაში გამოვიყენოთ, ის ძალიან მოხერხებული ხელსაწყოა.

- `*` - უმთავრესი ვაილდქარდი: იგი წარმოადგენს ნებისმიერ ერთეულს ან სტრინგს (ტექსტი)
- `?` - გამოიყენება ერთი ასოს აღსანიშნად
- `[]` - გამოიყენება ფრჩხილებს შორის ნებისმიერი ერთეულის აღსანიშნად

```bash
$ cp *.jpg /home/pridon/Pictures
```

ეს ბრძანება გადააკოპირებს მიმდინარე დირექტორიიდან ნებისმიერ ფაილს, რომელიც .jpg-ით ბოლოვდება, Picture-ის დირექტორიაში.

ხშირად ამ ბრძანებასთან ერთად გამოგვადგება `-r` ფლაგი, რომელიც რეკურსულად დააკოპირებს ფაილებსა და დირექტორიებს მითითებულ დირექტორიაში ([recursion-ის განმარტება](https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursion)).

სცადეთ `cp`-ს გამოყენება დირექტორიაზე, რომელიც შეიცავს რამდენიმე ფაილს და გადაიტანეთ ისინი Documents ფოლდერში. ალბათ არ გამოგივიდათ, არა? იმიტომ რომ საჭიროა დირექტორიასთან ერთად მაში არსებული ყველა სხვა ფაილის გადაკოპირებაც. სწორედ ამაზე მიუთითებს `-r` ფლაგი.

```bash
$ cp -r Khinklebi/ /home/pete/Documents
```

გასათვალისწინებელია, რომ თუ გადავაკოპირებთ ფაილს იმ დირექტორიაში, სადაც არსებობს ფაილი იმავე სახელით, პირველი ჩაანაცვლებს მეორეს. თუ შემთხვევით ეს გამოგვეპარა, შეიძლება მნიშვნელოვანი ფაილი დავკარგოთ! შეგვიძლია გამოვიყენოთ `-i` (interactive) ფლაგი, რომელიც ასეთ შემთხვევაში გაგვაფრთხილებს, რომ ფაილის ჩანაცვლება უწევს და ჩვენგან დასტურს დაელოდება.

```bash
$ cp -i mycoolfile /home/pridon/Pictures
```

# mv (ფაილის გადაადგილება)

ეს ბრძანება გამოიყენება ფაილების გადასაადგილებლად და, ამასთანავე, სახელის გადასარქმევად. ფლაგებისა და ფუნქციების მიხედვით, ის `cp` ბრძანებას ჰგავს.

ფაილებს სახელი ასე შეგვიძლია გადავარქვათ:

```bash
$ mv oldfile newfile
```

ფაილების სხვა დირექტორიაში გადატანა:

```bash
$ mv file2 /home/pridon/Documents
```

ერთზე მეტი ფაილის გადატანა:

```bash
$ mv file_1 file_2 /somedirectory

```

შესაძლებელია დირექტორიის/ფოლდერის სახელის გადარქმევაც:

```bash
$ mv directory1 directory2
```

ისევე როგორც `cp`, თუ ჩვენ `mv`-ით ფაილს ან ფოლდერს გადაავაადგილებთ, ის ყველაფერს გადაწერს, რასაც იგივე სახელი გააჩნია. ჩვენ შეგვიძლია გამოვიყენოთ `-i` ფლაგი, რათა პროგრამამ ამის თაობაზე გაგვაფრთხილოს.

```bash
$ mv -i directory1 directory2
```

# mkdir (ფოლდერის შექმნა)

ამდენ ფაილს, რომელზეც ჩვენ ვმუშაობთ, სადმე თავი უნდა მოვუყაროთ. `mkdir` ბრძანება (Make Directory) შექმნის დირექტორიას ჩვენი სასურველი სახელით, თუკი იმავე სახელით დირექტორია არ არსებობს მიმდინარე path-ზე. შესაძლებელია რამდენიმე დირექტორიის ერთდროულად შექმნაც.

```bash
$ mkdir books paintings
```

შესაძლებელია დირექტორიებთან ერთად სუბდირექტორიების შექმნაც, თუკი `-p` (parent flag) ფლაგს გამოვიყენებთ:

```bash
$ mkdir books/mikheil_javakhishvili/favorites
```

ეს ბრძანება შექმნის ფოლდერს books, რომელშიც იქნება მოთავსებული mikheil_javakhishvili, ხოლო ამ უკანასკნელში იქნება favorites ფოლდერი.

# rm (წაშლა)

ამ ეტაბზე ალბათ ბევრი არასაჭირო ფაილი დაგვიგროვდა, მოდით, რამდენიმე წავშალოთ.
ფაილებისა და ფოლდერების წასაშლელად ვიყენებთ `rm` (remove) ბრძანებას.

```bash
$ rm file1
```

`rm` ბრძანების გამოყენებისას ფრთხილად უნდა ვიყოთ, რადგან არ არსებობს რაიმე ჯადოსნური სანაგვე, რომლიდანაც წაშლილ ფაილებს დავიბრუნებთ. ამ ბრძანებით ფაილები სამუდამოდ იშლება.

საბედნიეროდ, არსებობს უსაფრთხოების ზომები, რათა ნებისმიერმა ადამიანმა არ შეძლოს მნიშვნელოვანი ფაილების წაშლა. მოდიფიკაციისგან დაცული ფაილები წაშლის მეორედ დადასტურებას მოგვთხოვენ (ხშირ შემთხვევაში მომხმარებლის ან „ადმინისტრატორის“ პაროლის ფორმით).

თუ ეს არ გვადარდებს, თავისუფლად შეგვიძლია ფაილების ერთბაშად წაშლა.

```bash
$ rm -f file1
```

`-f` ფლაგი (force) აცნობებს `rm` ბრძანებას, რომ წაშალოს ნებისმიერი ფაილი, მიუხედავად იმისა, დაცულია თუ არა, ყოველგვარი გაფრთხილების გარეშე (ამ დროს საჭიროა მომხმარებელს ჰქონდეს სათანადო უფლებები).

`-i` ფლაგი აქ, ისევე როგორც ბევრ სხვა ბრძანებაში, გვაჩვენებს დამადასტურებელ პრომპტს, მართლა გვინდა თუ არა კონკრეტული ფაილებისა თუ ფოლდერების წაშლა.

```bash
$ rm -i file
```

როცა იმ დირექტორიის წაშლა გვინდა, რომელსაც შიგნით გააჩნია სხვა ფაილები და სუბდირექტორიები, ჩვენ უნდა გამვიყენოთ `-r` ფლაგი, რაც ნიშნავს რეკურსულს ([recursion-ის განმარტება](https://www.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/recursion)). ის წაშლის მითითებულ ფოლდერს და ყველაფერს, რაც მასშია განთავსებული:

```bash
$ rm -r directory
```

უშუალოდ (ცარიელი) დირექტორიის წასაშლელად, შეგვიძლია გამოვიყენოთ `rmdir` (Remove Directory):

```bash
$ rmdir directory
```

# find (მოძებნა)

სისტემაში ძალიან ბევრი ფაილი შეიძლება დაგვიგროვდეს. კონკრეტული ფაილის მიგნება რთული იქნებოდა, `find` ბრძანება რომ არ არსებობდეს.

```bash
$ find /home -name khinkali.jpg
```

`find`-ით, ჩვენ უნდა დავაზუსტოთ დირექტორია, რომელშიც ძებნას ვახორციელებთ და ფაილი, რომელსაც ჩვენ ვეძებთ. ამ შემთხვევაში ჩვენ `/home` დირექტორიაში ვეძებთ ფაილს, რომელსაც ჰქვია khinkali.jpg.

ჩვენ, ასევე, შეგვიძლია დავაზუსტოთ რა ტიპის ფაილს ვეძებთ:

```bash
$ find /home -type d -name MyFolder
```

როგოგრც ხედავთ, აქ ფაილის ტიპში მივუთითე, რომ ვეძებ დირექტორიას (d) და ისევ ვუთითებ ფაილის სახელს MyFolder.

ერთი სასარგებლო თვისება, რაც `find`-ს ახასიათებს არის ის, რომ იგი არ გაჩერდება იმ დირექტორიაში, რომელშიც ძებნას ახორციელებ, არამედ გააგრძელებს ძებნას ამ ჩვენი დირექტორიის სუბდირექტორიებშიც (ასეთის არსებობის შემთხვევაში).

# help (დახმარება)

ლინუქსს აქვს ძალიან კარგი ინტეგრირებული ხელსაწყოები, რომლებიც გვეხმარება იმის გასარკვევად, როგორ გამოვიყენოთ ესა თუ ის ბრძანება, ან ვნახოთ რა ფლაგებია ხელმისაწვდომი კონკრეტული ბრძანებისთვის. ამ ხელსაწყოთაგან ერთ-ერთია bash-ში ინტეგრირებული `help` ბრძანება, რომელიც დაგვეხმარება bash-ში არსებული სხვა ბრძანებების გასაგებად.

```bash
$ help echo
```

ეს მოგვცემს `echo`-ს აღწერასა და პარამეტრებს, რომლებიც შეგვიძლია მასთან ერთად გამოვიყენოთ. სხვა პროგრამებისთვის კონვენციურად არსებობს `--hep` პარამეტრი (ან რამე მსგავსი).

```bash
$ echo --help
```

ასეთი პროგრამების შემქმნელი ყველა დეველოპერი არ მიყვება ამ სტანდარტს, მაგრამ უმეტესობა მაინც ურთავს დახმარების სექციას.

# man (ინსტრუქციების კატალოგი)

ნეტავ ამ პროგრამებისთვის არსებობდეს ინსტრუქციების კატალოგი, საიდანაც უფრო დეტალურ ინფორმაციას მივიღებდით. საბედნიეროდ არსებობს ბრძანება `man` (manual), რომელიც კონკრეტული პროგრამისთვის/ბრძანებისთვის განკუთვნილ ინსტრუქციების კატალოგს გვაჩვენებს.

```bash
$ man ls
```

Man-ის გვერდები არის დეტალური ისნტრუქციები, რომელიც ჩვეულებრივ მოყვება ლინუქსის ოპერატიულ სისტემეათა უმეტესობას. ისინი უზრუნველგვყოფენ ვრცელი დოკუმენტაციებით ბრძანებებისა და სისტემის სხვა ასპექტების შესახებ.

სცადეთ სხვადასხვა ბრძანებებისთვის man-ის მოხმობა რათა მეტი გაიგოთ მათ შესახებ. ეს არის უმთავრესი ხელსაწყო, როცა გვაინტერესებს როგორ გადავჭრათ ამოცანა და რა კონკრეტული ხელსაწყო გვჭირდება ამისათვის.

შეგიძლიათ `man` ბრძანება გამოიყენოთ უშუალოდ `bash`-ზე, და ეს მოგაწვდით მთლიანი შელის უზარმაზარ დოკუმებტაციას. მანდვე არის მოვემული ცალკეული ბრძანებების დოკუმენტაციებიც.

```bash
$ man bash
```

# whatis (რა არის)

იქნებ სანამ დეტალური ინფორმაციის გარჩევას შეუდგებით, უბრალოდ რაიმე ბრძანების ზოგადი და მოკლე აღწერა გაინტერესებთ? ამისთვის `whatis` ბრძანება გამოგვადგება.

```bash
$ whatis cat
```

აღწერა წყაროდ იყენებს პროგრამისთვის განკუთვნილი man-ის ამონარიდებს.

# alias (მეტსახელი)

ზოგჯერ შეიძლება ერთი და იმავე გრძელი ბრძანების წერა მოგვიწიოს. ამ დროს გამოგვადგება ასეთი გრძელი ბრძანებისთვის მეტსახელის მოგონება. ამისათვის უნდა მოვიხმოთ `alias` და მოვიფიქროთ სახელი, რომელსაც შემდგომ გავუტოლებთ ბრჭყალებში მოქცეულ იმ ბრძანებას, რომელიც გვინდა ამ მეტსახელით შევინახოთ.

```bash
$ alias all="ls -la"
```

ახლა, `ls -la`-ს მაგივრად შეგვიძლია დავუძახოთ `all`-ს და ის იგივე ბრძანებას განახორციელებს. გასათვალისწინებელია, რომ ეს მეტსახელი კომპიუტერის გადატვირთვის შემდეგ წაიშლება. რათა სამუდამოდ შევინახოთ მეტსახელი, ის უნდა ჩავწეროთ ჩვენს `~/.bashrc`-ში (ან `zsh`-ის შემთხვევაში `~/zshrc`).
ეს ის ფაილია, რომელსაც ბაში კითხულობს ყოველ ჯერზე, როცა შელი იხსნება.

ალიასების წაშლა შეგვიძლია შემდეგნაირად:

```bash
$ unalias some_alias
```

გაითვალისწინეთ, რომ თუ მეტსახელად გამოიყენებთ არსებული ბრძანების სახელს, ის ამ ბრძანებას ჩაანაცვლებს, სანამ ამ მეტსახელს არ წაშლით.

# exit (გასვლა)

როგორც იქნა გავედით ამ გაკვეთილის ბოლოში! ახლა შელის მხოლოდ ანა-ბანა ვიცით, ლაპარაკის სწავლა ჯერ კიდევ წინ გველის, მაგრამ ამ ცოდნითაც შეგიძლიათ შთამბეჭდავი რაღაცების გაკეთება.

დროა შევისვენოთ. შელიდან გამოსასვლელად შეგვიძლია გამოვიყენოთ ბრძანება:

```bash
$ exit
```

ან

```bash
$ logout
```

თუ გრაფიკული ტერმინალის აპლიკაციას იყენებთ, რა თქმა უნდა, შეგიძლიათ უბრალოდ ეგ აპლიკაცია დახუროთ.

წარმატებები!
